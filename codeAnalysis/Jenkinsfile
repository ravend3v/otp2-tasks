pipeline {
  agent any

  tools {
    dotnetsdk '.NET 9'
  }

  environment {
    PROJECT_DIR = "codeAnalysis"
    IS_UNIX = "${isUnix()}"

    // SonarQube
    SONAR_PROJECT_KEY= "jenkins-sonarqube-test"
    SONAR_PROJECT_NAME= "Jenkins SonarQube Test"

    // Docker
    DOCKER_HUB_CREDENTIALS = 'Docker'
    DOCKER_IMAGE_NAME = 'eliasoj/jenkins-sonarqube-test'
  }

  stages {
    stage('Checkout') {
      steps {
        checkout scm
      }
    }

    stage('SonarQube Begin') {
      steps {
        dir("${env.PROJECT_DIR}") {
          script {
            try {
              withSonarQubeEnv('LocalSonarQube') {
                def sonarBeginCmd = env.IS_UNIX == 'true' ?
                  "dotnet sonarscanner begin /k:\"${env.SONAR_PROJECT_KEY}\" /n:\"${env.SONAR_PROJECT_NAME}\" /d:sonar.login=\"\$SONAR_AUTH_TOKEN\" /d:sonar.host.url=\"\$SONAR_HOST_URL\" /d:sonar.cs.opencover.reportsPaths=\"reports/Calc.Tests/coverage.xml\" /d:sonar.cs.vstest.reportsPaths=\"reports/Calc.Tests/TestResults.trx\"" :
                  "dotnet sonarscanner begin /k:\"${env.SONAR_PROJECT_KEY}\" /n:\"${env.SONAR_PROJECT_NAME}\" /d:sonar.login=\"%SONAR_AUTH_TOKEN%\" /d:sonar.host.url=\"%SONAR_HOST_URL%\" /d:sonar.cs.opencover.reportsPaths=\"reports\\Calc.Tests\\coverage.xml\" /d:sonar.cs.vstest.reportsPaths=\"reports\\Calc.Tests\\TestResults.trx\""
                
                if (env.IS_UNIX == 'true') {
                  sh "dotnet tool restore"
                  sh sonarBeginCmd
                } else {
                  bat "dotnet tool restore"
                  bat sonarBeginCmd
                }
                env.SONAR_ENABLED = 'true'
              }
            } catch (Exception e) {
              echo "SonarQube begin failed: ${e.getMessage()}"
              echo "Continuing without SonarQube analysis"
              env.SONAR_ENABLED = 'false'
            }
          }
        }
      }
    }

    stage('Build & Test') {
      steps {
        dir("${env.PROJECT_DIR}") {
          script {
            def commands = [
              restore: env.IS_UNIX == 'true' ? 'dotnet restore src/codeAnalysis.csproj' : 'dotnet restore src\\codeAnalysis.csproj',
              build: env.IS_UNIX == 'true' ? 'dotnet build src/codeAnalysis.csproj -c Release --no-restore' : 'dotnet build src\\codeAnalysis.csproj -c Release --no-restore',
              cleanReports: env.IS_UNIX == 'true' ? 'rm -rf reports/Calc.Tests && mkdir -p reports/Calc.Tests' : 'if exist reports\\Calc.Tests rmdir /s /q reports\\Calc.Tests && mkdir reports\\Calc.Tests',
              test: env.IS_UNIX == 'true' ?
                'dotnet test tests/Calc.Tests/Calc.Tests.csproj --verbosity minimal --logger "trx;LogFileName=TestResults.trx" --results-directory reports/Calc.Tests /p:CollectCoverage=true /p:CoverletOutputFormat=opencover /p:CoverletOutput=../../reports/Calc.Tests/coverage.xml' :
                'dotnet test tests\\Calc.Tests\\Calc.Tests.csproj --verbosity minimal --logger "trx;LogFileName=TestResults.trx" --results-directory reports\\Calc.Tests /p:CollectCoverage=true /p:CoverletOutputFormat=opencover /p:CoverletOutput=..\\..\\reports\\Calc.Tests\\coverage.xml'
            ]

            if (env.IS_UNIX == 'true') {
              sh "${commands.restore}"
              sh "${commands.build}"
              sh "${commands.cleanReports}"
              sh "${commands.test}"
            } else {
              bat "${commands.restore}"
              bat "${commands.build}"
              bat "${commands.cleanReports}"
              bat "${commands.test}"
            }
          }
        }
      }
    }

    stage('SonarQube End & Quality Gate') {
      when {
        environment name: 'SONAR_ENABLED', value: 'true'
      }
      steps {
        dir("${env.PROJECT_DIR}") {
          script {
            withSonarQubeEnv('LocalSonarQube') {
              def sonarEndCmd = env.IS_UNIX == 'true' ?
                'dotnet sonarscanner end /d:sonar.login="$SONAR_AUTH_TOKEN"' :
                'dotnet sonarscanner end /d:sonar.login="%SONAR_AUTH_TOKEN%"'
              
              if (env.IS_UNIX == 'true') {
                sh sonarEndCmd
              } else {
                bat sonarEndCmd
              }
            }
            
            // Wait for SonarQube Quality Gate
            timeout(time: 5, unit: 'MINUTES') {
              def qg = waitForQualityGate()
              if (qg.status != 'OK') {
                error "Pipeline aborted due to quality gate failure: ${qg.status}"
              }
            }
          }
        }
      }
    }

    stage('Generate Coverage Report') {
      steps {
        dir("${env.PROJECT_DIR}") {
          script {
            // FIX APPLIED BELOW: Added quotes around "Html;Clover" in the Unix command
            def coverageCmd = env.IS_UNIX == 'true' ?
              'dotnet tool restore && dotnet tool run reportgenerator -reports:reports/Calc.Tests/coverage*.xml -targetdir:reports/Calc.Tests -reporttypes:"Html;Clover"' :
              'dotnet tool restore && dotnet tool run reportgenerator -reports:reports\\Calc.Tests\\coverage*.xml -targetdir:reports\\Calc.Tests -reporttypes:"Html;Clover"'

            if (env.IS_UNIX == 'true') {
              sh "if ls reports/Calc.Tests/coverage*.xml 1> /dev/null 2>&1; then ${coverageCmd}; else echo 'No coverage files found'; fi"
            } else {
              bat "if exist reports\\Calc.Tests\\coverage.xml (${coverageCmd}) else (echo No coverage.xml found)"
            }
          }
        }
      }
    }

    stage('Build Docker Image') {
      steps {
        dir("${env.PROJECT_DIR}") {
          script {
            if (env.IS_UNIX == 'true') {
              sh "docker build -t ${DOCKER_IMAGE_NAME}:latest ."
              sh "docker build -t ${DOCKER_IMAGE_NAME}:latest ."
            } else {
              bat "docker build -t ${DOCKER_IMAGE_NAME}:latest ."
              bat "docker build -t ${DOCKER_IMAGE_NAME}:latest ."
            }
          }
        }
      }
    }

    stage('Push to Docker Hub') {
      steps {
        script {
          withCredentials([usernamePassword(credentialsId: DOCKER_HUB_CREDENTIALS, usernameVariable: 'DOCKER_USERNAME', passwordVariable: 'DOCKER_PASSWORD')]) {
            if (env.IS_UNIX == 'true') {
              sh 'echo $DOCKER_PASSWORD | docker login -u $DOCKER_USERNAME --password-stdin'
              sh "docker push ${DOCKER_IMAGE_NAME}:latest"
              sh "docker push ${DOCKER_IMAGE_NAME}:latest"
            } else {
              bat 'echo %DOCKER_PASSWORD% | docker login -u %DOCKER_USERNAME% --password-stdin'
              bat "docker push ${DOCKER_IMAGE_NAME}:latest"
              bat "docker push ${DOCKER_IMAGE_NAME}:latest"
            }
          }
        }
      }
    }
  }

  post {
    always {
      dir("${env.PROJECT_DIR}") {
        archiveArtifacts artifacts: 'src/bin/**,reports/**', allowEmptyArchive: true
        
        script {
          // Only publish test results if they exist
          if (fileExists('reports/Calc.Tests/TestResults.trx')) {
            xunit tools: [[$class: 'MSTestJunitHudsonTestType', pattern: 'reports/**/*.trx']], 
                  thresholds: [[$class: 'FailedThreshold', unstableThreshold: '0'], 
                               [$class: 'SkippedThreshold', unstableThreshold: '0']]
          } else {
            echo 'No test results found to publish'
          }
        }

        script {
          try {
            step([$class: 'CloverPublisher', cloverReportDir: 'reports/Calc.Tests', cloverReportFileName: 'Clover.xml'])
          } catch (err) {
            echo "Clover publish failed: ${err}"
          }
        }

        publishHTML([
          allowMissing: true, alwaysLinkToLastBuild: true, keepAll: true,
          reportDir: 'reports/Calc.Tests', reportFiles: 'index.html',
          reportName: 'Code Coverage Report'
        ])
      }
    }

    cleanup {
      script {
        // Clean up Docker images to save space
        if (env.IS_UNIX == 'true') {
          sh "docker rmi ${DOCKER_IMAGE_NAME}:lates || true"
          sh "docker rmi ${DOCKER_IMAGE_NAME}:latest || true"
        } else {
          bat "docker rmi ${DOCKER_IMAGE_NAME}:latest || true"
          bat "docker rmi ${DOCKER_IMAGE_NAME}:latest || true"
        }
      }
    }
  }
}

